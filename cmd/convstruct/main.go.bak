// package main
// 
// import (
// 	"errors"
// 	"flag"
// 	"fmt"
// 	"go/ast"
// 	"go/format"
// 	"go/parser"
// 	"go/token"
// 	"io"
// 	"os"
// 	"strings"
// 
// 	"github.com/iancoleman/strcase"
// 	"github.com/jademperor/go-tools/pkg"
// )
// 
// // structType contains a structType node and it's name. It's a convenient
// // helper type, because *ast.StructType doesn't contain the name of the struct
// type structType struct {
// 	name string
// 	node *ast.StructType
// }
// 
// type output struct {
// 	// if the file empty, maybe need add package name
// 	pkgName string
// 
// 	// some imports need to add
// 	imports []*ast.ImportSpec
// 
// 	// struct type to output
// 	structTyp *ast.StructType
// 
// 	// convert function
// 	convertFunc *ast.FuncDecl
// }
// 
// func main() {
// 
// 	var (
// 		flagInput      = flag.String("input", "", "Filename to be parsed")
// 		flagStructName = flag.String("structName", "", "StructName to be parsed")
// 		flagOutput     = flag.String("output", "", "Filename to keep result")
// 		flagPkgName    = flag.String("pkgName", "", "Pkg name to output, only will be used when output file is not exist")
// 		flagOverwrite  = flag.Bool("ow", false, "Overwrite or not if output file has the struct name exist")
// 	)
// 
// 	flag.Parse()
// 
// 	cfg := &config{
// 		input:        *flagInput,
// 		inputImports: make(map[string]*ast.ImportSpec),
// 		structName:   *flagStructName,
// 		output:       *flagOutput,
// 		pkgName:      *flagPkgName,
// 		overwrite:    *flagOverwrite,
// 		r: &output{
// 			imports: make([]*ast.ImportSpec, 0),
// 		},
// 	}
// 	node, err := cfg.parse()
// 	if err != nil {
// 		panic(err)
// 	}
// 	structNode, err := cfg.findSelection(node)
// 	if err != nil {
// 		panic(err)
// 	}
// 
// 	out, err := cfg.generate(structNode)
// 	if err != nil {
// 		panic(err)
// 	}
// 	if err := cfg.write(out); err != nil {
// 		panic(err)
// 	}
// }
// 
// type config struct {
// 	input        string // input filepath to parse
// 	inputImports map[string]*ast.ImportSpec
// 	output       string // output filepath
// 	structName   string // target struct name
// 	pkgName      string // target package name, if is empty will set the output pkgname
// 	overwrite    bool   // overwrite or not
// 
// 	fset       *token.FileSet
// 	outFset    *token.FileSet
// 	w          io.Writer
// 	outputNode *ast.File
// 
// 	// result to write
// 	r *output
// }
// 
// func (c *config) parse() (ast.Node, error) {
// 	c.fset = token.NewFileSet()
// 	var contents interface{}
// 	inputNode, err := parser.ParseFile(c.fset, c.input, contents, parser.ParseComments)
// 	if err != nil {
// 		return nil, err
// 	}
// 
// 	// _pkg.
// 	c.outFset = token.NewFileSet()
// 	c.outputNode, err = parser.ParseFile(c.outFset, c.output, contents, parser.ParseComments)
// 	if err != nil {
// 		pkg.DebugF("parser.ParseFile(c.outFset, c.output, contents, parser.ParseComments) error: %v", err)
// 		return nil, err
// 	}
// 	// pkg name
// 	if c.pkgName == "" {
// 		c.pkgName = c.outputNode.Name.String()
// 	}
// 	c.r.pkgName = c.pkgName
// 
// 	// import spec
// 	for _, v := range inputNode.Imports {
// 		importName := ""
// 		if v.Name == nil {
// 			importName = parseImportName(v.Path.Value)
// 		} else {
// 			importName = v.Name.Name
// 		}
// 
// 		c.inputImports[importName] = &ast.ImportSpec{
// 			Name: ast.NewIdent(importName),
// 			Path: v.Path,
// 		}
// 		pkg.DebugF("[DEBUG] %s saved", importName)
// 	}
// 	pkg.DebugF("[DEBUG] c.inputImports= [%v]", c.inputImports)
// 
// 	return inputNode, nil
// }
// 
// // findSelection returns the start and end position of the fields that are
// // suspect to change. It depends on the line, struct or offset selection.
// func (c *config) findSelection(node ast.Node) (*ast.StructType, error) {
// 	return c.structSelection(node)
// }
// 
// func (c *config) structSelection(file ast.Node) (*ast.StructType, error) {
// 	structs := collectStructs(file)
// 
// 	var encStruct *ast.StructType
// 	for _, st := range structs {
// 		if st.name == c.structName {
// 			encStruct = st.node
// 		}
// 	}
// 
// 	if encStruct == nil {
// 		return nil, errors.New("struct name does not exist")
// 	}
// 
// 	// struct selects all lines inside a struct
// 	// start := c.fset.Position(encStruct.Pos()).Line
// 	// end := c.fset.Position(encStruct.End()).Line
// 
// 	return encStruct, nil
// }
// 
// // generate the node for structs and the [TODO: convert function]
// func (c *config) generate(node ast.Node) (*ast.StructType, error) {
// 	outNode := &ast.StructType{
// 		Fields: new(ast.FieldList),
// 	}
// 
// 	generateFunc := func(n ast.Node) bool {
// 		x, ok := n.(*ast.StructType)
// 		if !ok {
// 			return true
// 		}
// 
// 		for _, f := range x.Fields.List {
// 			fieldName := ""
// 			if len(f.Names) != 0 {
// 				fieldName = f.Names[0].Name
// 			}
// 
// 			// anonymous field
// 			if f.Names == nil {
// 				ident, ok := f.Type.(*ast.Ident)
// 				if !ok {
// 					pkg.DebugF("[DEBUG] could not convert Type(%v) to ast.Ident", f.Type)
// 					continue
// 				}
// 
// 				fieldName = ident.Name
// 			}
// 
// 			if typ, ok := f.Type.(*ast.SelectorExpr); ok {
// 				_pkgName := typ.X.(*ast.Ident).String()
// 				pkg.DebugF("[DEBUG] typ.X.Name()=[%s] need import", _pkgName)
// 				// add imports
// 				c.r.imports = append(c.r.imports, c.inputImports[_pkgName])
// 			}
// 
// 			outNode.Fields.List = append(outNode.Fields.List, c.process(fieldName, f.Type))
// 		}
// 
// 		return true
// 	}
// 
// 	ast.Inspect(node, generateFunc)
// 
// 	return outNode, nil
// }
// 
// // @filedName is input struct fileName
// // @typ is filed type
// func (c *config) process(fieldName string, typ ast.Expr) *ast.Field {
// 	pkg.DebugF("[DEBUG] fieldName: %s, typ: %s", fieldName, typ)
// 
// 	return &ast.Field{
// 		Doc: nil,
// 		Names: []*ast.Ident{
// 			ast.NewIdent(fieldName),
// 		},
// 		Type: typ,
// 		Tag: &ast.BasicLit{
// 			Value: quote(fmt.Sprintf(`json:"%s,omitempty"`, strcase.ToSnake(fieldName))),
// 		},
// 	}
// }
// 
// // generate package name
// // auto import need packages
// func (c *config) write(st *ast.StructType) (err error) {
// 	if c.w, err = os.OpenFile(c.output, os.O_RDWR, 0644); err != nil {
// 		return err
// 	}
// 
// 	// set package name
// 	if c.r.pkgName != "" {
// 		c.outputNode.Name = ast.NewIdent(c.r.pkgName)
// 	}
// 
// 	// add imports
// 	c.outputNode.Imports = append(c.outputNode.Imports, c.r.imports...)
// 	pkg.DebugF("[DEBUG] c.outputNode.Imports has: [%v]", c.outputNode.Imports)
// 
// 	// endPos := c.outputNode.End()
// 	// add struct decl
// 	_decl := &ast.GenDecl{
// 		// Doc: nil,
// 		// TokPos: nil,
// 		Tok: token.TYPE,
// 		// Lparen: nil,
// 		Specs: []ast.Spec{
// 			&ast.TypeSpec{
// 				Doc:  nil,
// 				Name: ast.NewIdent(c.structName),
// 				// Assign:  nil,
// 				Type:    st,
// 				Comment: nil,
// 			},
// 		},
// 		// Rparen: nil,
// 	}
// 	_ = _decl
// 	// c.outputNode.Decls = append(c.outputNode.Decls, _decl)
// 
// 	// TODO: add func decl
// 
// 	return format.Node(c.w, c.outFset, c.outputNode)
// 	// return printer.Fprint(c.w, c.outFset, c.outputNode)
// }
// 
// // collectStructs collects and maps structType nodes to their positions
// func collectStructs(node ast.Node) map[token.Pos]*structType {
// 	structs := make(map[token.Pos]*structType, 0)
// 	collectStructs := func(n ast.Node) bool {
// 		var t ast.Expr
// 		var structName string
// 
// 		switch x := n.(type) {
// 		case *ast.TypeSpec:
// 			if x.Type == nil {
// 				return true
// 			}
// 
// 			structName = x.Name.Name
// 			t = x.Type
// 		case *ast.CompositeLit:
// 			t = x.Type
// 		case *ast.ValueSpec:
// 			structName = x.Names[0].Name
// 			t = x.Type
// 		}
// 
// 		x, ok := t.(*ast.StructType)
// 		if !ok {
// 			return true
// 		}
// 
// 		structs[x.Pos()] = &structType{
// 			name: structName,
// 			node: x,
// 		}
// 		return true
// 	}
// 	ast.Inspect(node, collectStructs)
// 	return structs
// }
// 
// func quote(tag string) string {
// 	return "`" + tag + "`"
// }
// 
// func parseImportName(path string) string {
// 	path = strings.Trim(path, `"`)
// 	sl := strings.Split(path, "/")
// 	return sl[len(sl)-1]
// }
